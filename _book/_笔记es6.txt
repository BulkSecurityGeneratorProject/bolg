let 和 const 命令
变量的解构赋值
字符串的扩展
正则的扩展
数值的扩展
Math扩展
数组扩展
函数的扩展
对象的扩展
Symbol
Set 和 Map 数据结构
Proxy
Reflect
Promise 对象
Iterator 和 for...of 循环
Generator 函数的语法
Generator 函数的异步应用
async 函数
Class 的基本语法
Class 的继承
Decorator
Module 的语法
Module 的加载实现
编程风格
ArrayBuffer

es2015(es6):
    Default Parameters（默认参数） function(height = 50)
    Template Literals （模板文本） `Your name is ${first} ${last}. `
    Multi-line Strings （多行字符串） `Then 换行 aabbcc`
    Destructuring Assignment （解构赋值） {username, password} = req.body
    Enhanced Object Literals （增强的对象文本） [ 'valueOf_' + getAccounts().join('_') ]
    Arrow Functions （箭头函数）=>
    Promises （异步） new Promise(
    Block-Scoped Constructs Let and Const（块作用域构造Let and Const）
    Classes（类）
    Modules（模块）

    全新的Math, Number, String, Array 和 Object 方法
    二进制和八进制数据类型
    默认参数不定参数扩展运算符 ...
    Symbols符号
    tail调用
    Generators (生成器)
    New data structures like Map and Set(新的数据构造对像MAP和set)

es2016(es7):
    Array.prototype.includes (Domenic Denicola, Rick Waldron)
    指数运算符Exponentiation Operator (Rick Waldron)
        x ** y // Math.pow(x, y)

es2017(es8):
    异步函数 (Brian Terlson)
        * yield
        async await
    共享内存和原子 (Lars T. Hansen)
        SharedArrayBuffer Atomics
    Object.values/Object.entries (Jordan Harband)
    字符串填充 (Jordan Harband, Rick Waldron)
        padStart padEnd
    Object.getOwnPropertyDescriptors() (Jordan Harband, Andrea Giammarchi)
    在函数参数列表和调用中减少逗号的使用 (Jeff Morrison)

1. ES6-声明变量的六种方法：var,function,let,const,import,class
2. ES6规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。
3. Symbol、undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）
4.异步编程：回调函数、事件监听、发布/订阅、Promise 对象、Generator 函数


24、编程风格
    1、块级作用域 (const,let)
        1.let 取代 var
        2.优先使用const
            所有的函数都应该设置为常量
            全局环境，不应该设置变量，只应设置常量
            const可以提醒阅读程序的人，这个变量不应该改变；
            const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；
            JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率

    2、字符串 (`)
        静态字符串使用单引号或反引号，不使用双引号。动态字符串使用反引号
            'foobar'  `foo${a}bar`

    3、解构赋值 ({a}=obj)
        使用数组成员对变量赋值时，优先使用解构赋值
            const [first, second] = arr;
        函数的参数如果是对象的成员，优先使用解构赋值。
            function a(user) {const first = user.first;const last = user.last;// bad
            function a(obj) {const { first, last } = obj;// good
            function a({ first, last }) {}// best
        返回多个值，优先使用对象的解构赋值
            function processInput(input) {return { left, right, top, bottom };}
            const { left, right } = processInput(input);

    4、对象 (保持对象静态)
        单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾
            const a = { k1: v1, k2: v2 };
            const b = {
                k1: v1,
                k2: v2,
            };
        对象尽量静态化，不得随意添加新的属性。不可避免，要使用Object.assign方法。
            const a = {};Object.assign(a, { x: 3 });//不可避免
            const a = { x: null };a.x = 3;// good
        如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义
            const obj = {
                [getKey('enabled')]: true,
                addValue(value) { //简洁
                    return atom.value + value;
                },
            };

    5、数组 (rest运算符...)
        使用扩展运算符（...）拷贝数组
            const itemsCopy = [...items];
        用Array.from方法，将类似数组的对象转为数组。
            const foo = document.querySelectorAll('.foo');
            const nodes = Array.from(foo);

    6、函数 (箭头函数)
        立即执行函数可以写成箭头函数的形式
            (() => {
                console.log('Welcome to the Internet.');
            })();
        需要使用函数表达式的场合，尽量用箭头函数代替
            [1, 2, 3].map(function (x) {return x * x;});// bad
            [1, 2, 3].map((x) => {return x * x;});// good
            [1, 2, 3].map(x => x * x);// best
        取代Function.prototype.bind
            self = this;boundMethod = function(...params) {return method.apply(self, params);}// bad
            const boundMethod = method.bind(this);// acceptable
            const boundMethod = (...params) => method.apply(this, params);// best
        如果函数体较为复杂，行数较多，还是应该采用传统的函数写法
        所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数
            function divide(a, b, option = false ) {} // bad
            function divide(a, b, { option = false } = {}) {}// good
        不要在函数体内使用arguments变量，使用rest运算符（...）代替。
            function a() {  const args = Array.prototype.slice.call(arguments);  return args.join('');// bad
            function a(...args) {  return args.join('');}// good
        使用默认值语法设置函数参数的默认值。
            function handleThings(opts) {opts = opts || {};}// ba
            function handleThings(opts = {}) {// ...}// good

    7、Map结构(键值对)
        Object 模拟现实世界的实体对象
        Map 需要key: value的数据结构，内建的遍历机制
            let item of map.entries()

    8、Class(prototype)
        总是用Class，取代需要prototype的操作
            // bad
            function Queue(contents = []) {this._queue = [...contents];}
            Queue.prototype.pop = function() {return this._queue[0];}
            // good
            class Queue {
                constructor(contents = []) {this._queue = [...contents];}
                pop() {return this._queue[0];}
            }
        使用extends实现继承

    9、模块
        使用import取代require
        使用export取代module.exports
            // commonJS的写法
            var React = require('react');
            var Breadcrumbs = React.createClass({
              render() {
                return <nav />;
              }
            });
            module.exports = Breadcrumbs;
            // ES6的写法
            import React from 'react';
            class Breadcrumbs extends React.Component {
              render() {
                return <nav />;
              }
            };
            export default Breadcrumbs;
        如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，export default与普通的export不要同时使用
        不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出
            import * as myObject './importModule';// bad
            import myObject from './importModule';// good
        如果模块默认输出一个函数，函数名的首字母应该小写。
        如果模块默认输出一个对象，对象名的首字母应该大写。

    10、ESLint的使用


1、let,const:
    let类似var，但只在let命令所在的代码块内有效
            (eg: {let a=10;};a;)
    const声明一个只读的常量
            (eg: const PI = 3.1415;PI = 3;  const foo;//报错)
    const实际上保存内存地址，对象和数组可改变内容
            (eg: const foo = Object.freeze({});//对象冻结，彻底冻结还需要递归)
    每一次循环的i都是一个新的变量
            (eg: var a=[];for(let i=0;i<10;i++){a[i]=function(){console.log(i);};};a[6](); )
    for循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域
            (eg: for (let i = 0; i < 3; i++) {let i = 'abc';console.log(i);})
    不存在变量提升
            (eg: console.log(bar);let bar=2;)
  **暂时性死区TDZ
            (eg: var tmp = 123;{tmp='abc';let tmp;}   typeof x;let x;//报错   let x = x;//报错)
    不允许重复声明
            (eg: function () {let a = 10;var a = 1;})
    块级作用域
            (eg: {let tmp = ...;}//立即执行函数)
    非顶层变量，不挂在window上
            (eg: let b = 1;window.b // undefined)
    顶层global-对象
            (eg: import getGlobal from 'system.global';const global = getGlobal();)

2、解构赋值:
    ...
            (eg: let aaa= [1, 2, 3, 4] => let [...tail1] = [1, 2, 3, 4] )
    不完全结构
            (eg: let [a, [b], d] = [1, [2, 3], 4];b //2)
    可以设置默认值
            (eg: let [x = 1] = [undefined];x // 1   let [x = 1] = [null];x // null   let [x = f()] = [1];//不调用，需要才调)
    对象解构机制，key不会赋值进去
            (eg: let { foo: baz } = { foo: "aaa", bar: "bbb" };foo;//报错   let foo;({foo}={foo: 1});)
    数组第一个和最后一个
            (eg: let {0 : first, [arr.length - 1] : last} = arr;)
    函数结构
            (eg: [[1, 2], [3, 4]].map(([a, b]) => a + b);)
    少用括号
            (eg: [(a)] = [1];({ p: (d) } = {});)
    交换变量的值
            (eg: [x, y] = [y, x];)
    从函数返回多个值，函数参数的定义，提取JSON数据，函数参数的默认值，遍历Map结构（for (let [key, value] of map)，输入模块的指定方法（const { a, b } = require("source-map");）

3、字符串扩展:
    Unicode表示法
            (eg: "\u0061"   "\u{20BB7}"   let lo=123;l\u{6F}//123   '\u{1F680}' === '\uD83D\uDE80'   '\z' === '\172' === '\x7A' === '\u007A' === '\u{7A}' === 'z' // true)
    codePointAt
            (eg: for (let ch of s) {console.log(ch.codePointAt(0).toString(16));}//获得字符 function is32Bit(c) {return c.codePointAt(0) > 0xFFFF;}//测试一个字符由两个字节还是由四个字节组成)
    String.fromCodePoint优化
            (eg: String.fromCodePoint(0x20BB7);)
    for..of循环得到值
    .at()
            (eg: '𠮷'.at(0) // "𠮷" 目前不支持需要垫片库)
    normalize()
            (eg: '\u01D1'.normalize() === '\u004F\u030C'.normalize();//Ǒ===Oˇ NFC,NFD,NFKC,NFKD)
    .includes(str,index)  .startsWith(str,index)  s.endsWith(str,index)
            //endsWith的index针对前n个字符，其他针对从第n个位置直到结束
    .repeat(num)重复字符串
    .padStart(long,str).padEnd(long,str)//补全字符，long小于字符串则返回原字符串
    模板字符串``支持多行
            (eg: `${a+b}`  const tmpl = addrs => `<table>${addrs.map(addr => `<tr><td>${addr.first}</td></tr><tr><td>${addr.last}</td></tr></table>`).join('')//嵌套}
    标签模板：过滤HTML字符串，多语言转换，嵌入其他语言
    String.raw()转义斜杠，变量替换

4、正则扩展
    u修饰符+量词
            (eg: /𠮷{2}/u.test('𠮷𠮷'))
    y修饰符 粘连，从剩余的第一个位置，
    .sticky是否有y .source正则内容 .flags正则修饰符
    RegExp.escape 字符串转义（转义后再正则）
            (eg: str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');)
    . 不能匹配\n 用[^]  s修饰符(还未支持)
            (eg: /foo[^]bar/.test('foo\nbar'))
    目前支持先行断言，提案支持后行断言
    Unicode属性类提案  /\p{Script=Greek}/u.test('π')

5、数值扩展
    二进制0b和八进制数值0o
            (eg: Number('0b111')   Number('0o10'))
    Number.isFinite()和Number.isNaN()
            与全局方法isFinite()和isNaN()的区别在于不先调用Number() return typeof value === 'number' && global_isNaN(value);
    Number.parseInt(), Number.parseFloat() 和全局全局方法parseInt()和parseFloat()全等
    Number.isInteger是否为整数
            return typeof value === 'number' && isFinite(value) && value > -9007199254740992 && value < 9007199254740992 && floor(value) === value;
    Number.EPSILON 极小的常量 表示可以接受的误差范围
    安全整数和Number.isSafeInteger  是否在Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER之间
            (eg:   return (typeof n === 'number' && Math.round(n) === n && Number.MIN_SAFE_INTEGER <= n && n <= Number.MAX_SAFE_INTEGER);)

6、Math扩展
    Math.trunc() 去除一个数的小数部分
            return x < 0 ? Math.ceil(x) : Math.floor(x);
    Math.sign() 判断一个数到底是正数、负数、还是零
            x = +x; if (x === 0 || isNaN(x)) {return x;} return x > 0 ? 1 : -1;
    Math.cbrt() 算一个数的立方根
            var y = Math.pow(Math.abs(x), 1/3);return x < 0 ? -y : y;
    Math.clz32() 返回32位无符号整数形式有多少个前导0
            Math.clz32(0b00100000000000000000000000000000);//2
    Math.imul() 以32位带符号整数形式相乘,超过有效数值
            (a * b)|0
    Math.fround() 方法返回一个数的单精度浮点数形式
            return new Float32Array([x])[0];
    Math.hypot() 返回所有参数的平方和的平方根
    对数方法
    Math.expm1(x)返回ex - 1 return Math.exp(x) - 1;
    Math.log1p(x)方法返回1 + x的自然对数 return Math.log(1 + x);
    Math.log10(x)返回以10为底的x的对数 return Math.log(x) / Math.LN10;
    Math.log2(x)返回以2为底的x的对数 return Math.log(x) / Math.LN2;
    三角函数
    Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）
    Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）
    Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）
    Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）
    Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）
    Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）
    ** 类似Math.pow   b **= 3;// 等同于 b = b * b * b;
            V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。

7、数组扩展
    Array.from() 将类似数组的对象(必须有length属性)、字符串、set类、...转为真正的数组（length,0,1,2...）
            Array.from(arguments) --> [].slice.call(obj)  类似[...arguments]
            Array.from(arrayLike,x=>x*x); --> Array.from(arrayLike).map(x=>x*x);
            取出dom文本内容，Array.prototype.map.call(spans, s => s.textContent);Array.from(spans, s => s.textContent)
            Array.from({ length: 2 }, (a,b) => b) 初始化数组
            Array.from(string).length; 避免将大于\uFFFF的Unicode字符，算作两个字符的bug
    Array.of() 用于将一组值，转换为数组 替代Array()或new Array()
            等价 [].slice.call(arguments);
    copyWithin() 在当前数组内部，将指定位置的成员复制到其他位置
            [1, 2, 3, 4, 5].copyWithin(1, 2,4);//[1, 3, 4, 4, 5]
    find() 用于找出第一个符合条件的数组成员,没有返回undefined  findIndex()返回第一个符合条件的数组成员的位置，没有返回-1
            两个方法都可以发现NaN,弥补了数组的IndexOf方法的不足
    fill() 方法使用给定值，填充一个数组
            ['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c']
    entries() keys()和values()——用于遍历数组 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历
            for (var [index, elem] of ['a', 'b'].entries()) {console.log(index, elem);}
    includes() 返回bool，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持
            indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判
            等价arr.some(el => el === value)
    空位 ES6明确将空位转为undefined

8、函数扩展
    函数的参数指定默认值
            function Point(x = 0, y = 0) { 默认值是变量惰性求值
            undefined会触发默认值，null则没有这个效果
            与解构赋值的默认值，结合function fetch(url, { method = 'GET' } = {})
            作用域  设置了参数的默认值，函数进行声明初始化时let，参数会形成一个单独的作用域let x = 1;function f(y = x) {let x = 2;console.log(y);}f(3)//3
    rest参数  用于获取函数的多余参数
            sortNumbers = (...numbers) => numbers.sort();
            只能是最后一个参数
    length属性 该函数预期传入的参数个数，等于函数的参数个数减去指定了默认值的参数个数
            (function (a = 0, b, c) {}).length // 0
            (function (a, b = 1, c) {}).length // 1
            (function (a, b, c = 5) {}).length // 2
            (function(...args) {}).length // 0
    扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。
            主要用于函数调用function add(x, y) {return x + y;}var numbers = [4, 38];add(...numbers);
            不用最后一个参数，自由
            代替apply，方便Math.max(...arr);arr1.push(...arr2);new Date(...[2015, 1, 1]);
            1.合并数组:arr1.concat(arr2, arr3); -> [...arr1, ...arr2, ...arr3]
            2.与解构赋值结合,只能放最后:a = list[0], rest = list.slice(1) -> [a, ...rest] = list
            3. 字符串[...'hello']// [ "h", "e", "l", "l", "o" ]
            4.[...'x\uD83D\uDE80y'].length 和 Array.from('x\uD83D\uDE80y').length 一样
            5.任何Iterator接口的对象，都可以用扩展运算符转为真正的数组  转化弱于Array.from
    name属性
            f = function () {};f.name //"f" 如果将一个匿名函数赋值给一个变量， ES6 的name属性会返回实际的函数名。
            bar = function baz() {}; //"baz" ES6
            (new Function).name // "anonymous"匿名
            foo.bind({}).name // "bound foo"
            (function(){}).bind({}).name // "bound "
    箭头函数
            1.this指向的固定化。函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。
                不能用call()、apply()、bind()这些方法去改变this的指向
            2.不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
            3.不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。
            4.不可以使用yield命令，因此箭头函数不能用作 Generator 函数。
            () => {};() => ({});() => 5;v =>v;(num1, num2) => { return num1 + num2; };
            ({ first, last }) => first + ' ' + last; //(person) {return person.first + ' ' + person.last;}
    嵌套箭头函数
            pipeline = (...funcs) => val => funcs.reduce((a, b) => b(a), val);
    函数绑定运算符是并排的两个冒号(::) es7,babel支持
            foo::bar; 等价 bar.bind(foo);
            foo::bar(...arguments); 等价 bar.apply(foo, arguments);
            method = obj::obj.foo; 等价 method = ::obj.foo;
            可采用链式写法
    尾调用优化 只保留内层函数的调用帧 ,只在严格模式下开启
            采用循环换掉递归，也可以实现
            function f(x){return g(x);}//某个函数的最后一步是调用另一个函数
            //function f(x){let y = g(x);return y;}//不算
            //function f(x){return g(x) + 1;}//不算
            //function f(x){g(x);}//不算
            function f() {let m = 1;let n = 2;return g(m + n);}  ->  g(3);
            function addOne(a){var one = 1;function inner(b){return b + one;}return inner(a);}//层函数用到了外层函数变量，不会优化
    尾递归 只存在一个调用帧 (测试还是会溢出)
            递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）
            Fibonacci 优化
            function Fibonacci (n) {if ( n <= 1 ) {return 1};return Fibonacci(n - 1) + Fibonacci(n - 2);}
            function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {if( n <= 1 ) {return ac2};return Fibonacci2 (n - 1, ac2, ac1 + ac2);}
            柯里化（currying），意思是将多参数的函数转换成单参数的形式
    函数参数有尾逗号
            function clownsEverywhere(param1,param2,) { /* ... */ }

9、对象扩展
    属性的简洁表示法
            foo = 'bar';baz = {foo}; 等同 baz = {foo: foo};
            function f(x, y) {return {x, y};} 等同 function f(x, y) {return {x: x, y: y};}
            var o = {method() {return "Hello!";}}; 等同 var o = {method: function() {return "Hello!";}};
            module.exports = { getItem, setItem, clear }; 等同 module.exports = {getItem: getItem,setItem: setItem,clear: clear};
    属性名表达式，不能和简洁表示法同用,不能是对象
            var a = {["a"+"b"]: 'ab'};
            var baz = { [foo] };//报错
    Object.is 同 ===，但  Object.is(+0,-0)==false  Object.is(NaN,NaN)==true
            if (x === y) {return x !== 0 || 1 / x === 1 / y;} return x !== x && y !== y;
    Object.assign 对象的合并 浅拷贝 不拷贝继承和不可枚举的属性
            Object.assign({a:1,b:1},{a:2},{c:1});//{a: 2, b: 1, c: 1}
            数组，字符串也可拷贝
            为属性指定默认值 Object.assign({}, DEFAULTS, options)
            enumerable为false  for in、Object.keys()、JSON.stringify()、Object.assign会忽略
            所有Class的原型的方法都是不可枚举 Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, 'foo').enumerable//false
    属性的遍历
            1.for...in    for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。
            2.Object.keys(obj)    Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。
            3.Object.getOwnPropertyNames(obj)    Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。
            4.Object.getOwnPropertySymbols(obj)    Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。
            5.Reflect.ownKeys(obj)    Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管属性名是Symbol或字符串，也不管是否可枚举
    __proto__属性，不推荐使用
            最好使用下面的Object.setPrototypeOf()写、Object.getPrototypeOf()读、Object.create()生成 代替。
            Object.setPrototypeOf(object, prototype)等同function (obj, proto) {obj.__proto__ = proto;return obj;}
            Object.getPrototypeOf(obj);等同function (obj) {return obj.__proto__;}
    Object.keys,Object.values,Object.entries  只返回对象自身的可遍历属性
    扩展运算符
            { x,...z } = { x: 1, y: 2}; x=1;z = { y:2 } 放在最后
            如果是对象就只存引用，不会拷贝继承自原型对象
            var o = Object.create({ x: 1, y: 2 });o.z=3;let { x,...{ y,z}}=o;x=1;y=undefined;z=3;
            { ...a }; 等同 Object.assign({}, a);
            { ...a, ...b }; 等同 Object.assign({}, a, b);
            { ...null, ...undefined }; // 忽略，不报错
    Object.getOwnPropertyDescriptor(obj, 'p') es5返回某个对象属性的描述对象
    Object.getOwnPropertyDescriptors(obj) es6返回指定对象所有自身属性（非继承属性）的描述对象
            obj = {set foo(value) {}};
            Object.assign({}}, obj);//无法正确拷贝get属性和set属性
            Object.defineProperties({}}, Object.getOwnPropertyDescriptors(obj));
    const obj = {__proto__: prot,foo: 123,};
            obj = Object.create(prot);obj.foo = 123;
            obj = Object.assign(Object.create(prot),{foo: 123,});
            Object.create(prot,Object.getOwnPropertyDescriptors({foo: 123,}));
    Null传导运算符 提案
            1.obj?.prop // 读取对象属性
            2.obj?.[expr] // 同上
            3.func?.(...args) // 函数或对象方法的调用
            4.new C?.(...args) // 构造函数的调用
            message?.body?.user?.firstName || 'default'; a?.b = 42

10、Symbol 防止属性名的冲突,每次结果不同
    Symbol()!==Symbol()
            不能与其他类型的值进行运算
            可以转为字符串、布尔值，但是不能转为数值
    Symbol 值作为对象属性名
            {[Symbol()]: 'Hello!'}
            {[Symbol()](arg) { ; }}
            不能用点运算符
            不会出现在 for...in、for...of、Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()
            为对象定义一些非私有的、但又希望只用于内部的方法
    消除魔术字符串
            魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值
            const shapeType = {triangle: Symbol()};
    Object.getOwnPropertySymbols
            返回所有用作属性名的 Symbol 值
    Symbol.for(str) 先检查给定的key是否已经存在，如果不存在才会新建一个值
            Symbol.for() //Symbol(undefined)
            全局环境,，iframe 窗口生成的 Symbol 值，可以在主页面得到
    Symbol.keyFor()  返回一个已登记的 Symbol 类型值的key
            Symbol.keyFor(Symbol.for("a"))=="a"
    Singleton模式 指的是调用一个类，任何时候返回的都是同一个实例
            const FOO_KEY = Symbol('foo');
    Symbol.hasInstance 指向一个内部方法
            class Even {static [Symbol.hasInstance](obj) {return Number(obj) % 2 === 0;}}
            1 instanceof Even//false
    Symbol.isConcatSpreadable 表示该对象使用Array.prototype.concat()时，是否可以展开
            true或undefined 可展开   false 不可展开
            arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e']
            类似数组的对象默认为false，必须手动打开
            obj = {length: 2, 0: 'c', 1: 'd'};obj[Symbol.isConcatSpreadable] = true;['a', 'b'].concat(obj, 'e')  // ['a', 'b', 'c', 'd', 'e']
    Symbol.species 指向当前对象的构造函数
            class MyArray extends Array {
                static get [Symbol.species]() { return Array; }// 覆盖父类 Array 的构造函数
            }
            var a = new MyArray(1,2,3); var mapped = a.map(x => x * x);
            mapped instanceof MyArray // false  mapped instanceof Array // true
            上面代码中，由于构造函数被替换成了Array。所以，mapped对象不是MyArray的实例，而是Array的实例
    Symbol.match 指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值
            String.prototype.match(regexp) 等同 regexp[Symbol.match](this)
    Symbol.replace  指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值
            String.prototype.replace(searchValue, replaceValue) 等同 searchValue[Symbol.replace](this, replaceValue)
            'Hello'.replace(x, 'World')  Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象Hello，第二个参数是替换后的值World
    Symbol.search
            String.prototype.search(regexp) 等同 regexp[Symbol.search](this)
    Symbol.split
            String.prototype.split(separator, limit) 等同 separator[Symbol.split](this, limit)
    Symbol.iterator属性，指向该对象的默认遍历器方法
            对象进行for...of循环时，会调用
    Symbol.toPrimitive属性，该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值
            Number：该场合需要转成数值
            String：该场合需要转成字符串
            Default：该场合可以转成数值，也可以转成字符串
            let obj = {
                [Symbol.toPrimitive](hint) {
                    switch (hint) {
                        case 'number':return 123;
                        case 'string':return 'str';
                        case 'default':return 'default';
                        default:throw new Error();
                    }
                }
            };
            2 * obj // 246
            3 + obj // '3default'
            obj == 'default' // true
            String(obj) // 'str'
    Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时
            JSON[Symbol.toStringTag]：'JSON'
            Math[Symbol.toStringTag]：'Math'
            Module对象M[Symbol.toStringTag]：'Module'
            ArrayBuffer.prototype[Symbol.toStringTag]：'ArrayBuffer'
            DataView.prototype[Symbol.toStringTag]：'DataView'
            Map.prototype[Symbol.toStringTag]：'Map'
            Promise.prototype[Symbol.toStringTag]：'Promise'
            Set.prototype[Symbol.toStringTag]：'Set'
            %TypedArray%.prototype[Symbol.toStringTag]：'Uint8Array'等
            WeakMap.prototype[Symbol.toStringTag]：'WeakMap'
            WeakSet.prototype[Symbol.toStringTag]：'WeakSet'
            %MapIteratorPrototype%[Symbol.toStringTag]：'Map Iterator'
            %SetIteratorPrototype%[Symbol.toStringTag]：'Set Iterator'
            %StringIteratorPrototype%[Symbol.toStringTag]：'String Iterator'
            Symbol.prototype[Symbol.toStringTag]：'Symbol'
            Generator.prototype[Symbol.toStringTag]：'Generator'
            GeneratorFunction.prototype[Symbol.toStringTag]：'GeneratorFunction'
    Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除
            Array.prototype[Symbol.unscopables]

11、Set 和 Map 数据结构
    Set数据结构
            类似于数组，但是成员的值都是唯一的，没有重复的值
            可以用Array.from转化或...
            set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]
            [...new Set(array)]// 去除数组的重复成员
            判断两个值是否不同类似于精确相等运算符（===），区别是NaN等于自身
    Set 结构的实例有以下属性。
            Set.prototype.constructor：构造函数，默认就是Set函数。
            Set.prototype.size：返回Set实例的成员总数。
    Set 操作方法（用于操作数据）
            add(value)：添加某个值，返回Set结构本身。
            delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
            has(value)：返回一个布尔值，表示该值是否为Set的成员。
            clear()：清除所有成员，没有返回值。
    Set 遍历方法（用于遍历成员） keys方法和values方法的行为完全一致
            keys()：返回键名的遍历器
            values()：返回键值的遍历器  for (let item of set.values()) { == for (let x of set) {
            entries()：返回键值对的遍历器
            forEach()：使用回调函数遍历每个成员  set.forEach((value, key) => console.log(value * 2) )
    WeakSet 能放置对象。弱引用 不可遍历
            new WeakSet([[1, 2], [3, 4]])
            WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员。
            WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员。
            WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。
            使用WeakSet的好处是，对实例的引用不会被计入内存回收机制，所以删除实例的时候，也不会出现内存泄漏
    Map key可以是各种类型的值（包括对象）
            map = new Map([[{p: '1'}, '张三'],['title', 'Author']]);
            key等价：0和-0，NaN和NaN
            不等价：undefined和null，'true'和true
            方法：.size、.set(key, value)链式、.get(key)、.has(key)、.delete(key)、.clear()
            遍历：keys()、values()、entries()、forEach()第二个参数，用来绑定this
                map[Symbol.iterator] === map.entries
            new Map([...map0].filter(([k, v]) => k < 3));
            new Map([...map0].map(([k, v]) => [k * 2, '_' + v]));
    Map转换
            1.Map转为数组 [...myMap]
            2.数组转为 Map new Map([[true, 7],[{foo: 3}, ['abc']]])
            3.Map 转为对象 function strMapToObj(strMap) {let obj = Object.create(null);for (let [k,v] of strMap) {obj[k] = v;}return obj;}
            4.对象转为 Map function objToStrMap(obj) {let strMap = new Map();for (let k of Object.keys(obj)) {strMap.set(k, obj[k]);}return strMap;}
            5.Map 转为 JSON JSON.stringify(strMapToObj(strMap)); key非字符串JSON.stringify([...map])
            6.JSON 转为 Map objToStrMap(JSON.parse(jsonStr)) 或 new Map(JSON.parse(jsonStr))
    WeakMap 与Map的区别 1.只接受对象作为键名（null除外）2.键名所指向的对象，不计入垃圾回收机制
            WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。
            弱引用的只是键名，而不是键值
            只有get()、set()、has()、delete()
            1.注册监听事件的listener对象
                listener = new WeakMap();
                listener.set(element1, handler1);
                element1.addEventListener('click', listener.get(element1), false);
            2.部署私有属性

12、Proxy
    Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。
            var proxy = new Proxy(target, handler);target表示所要拦截的目标对象，handler也是一个对象，用来定制拦截行为
            proxy为target的最强后结果
            1.get(target, propKey, receiver)
                拦截对象属性的读取，比如proxy.foo和proxy['foo']。最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。
            2.set(target, propKey, value, receiver)
                拦截对象属性的设置，比如proxy.foo = v或proxy['foo'] = v，返回一个布尔值。
            3.has(target, propKey)
                拦截propKey in proxy的操作，返回一个布尔值。拦截的是HasProperty操作，而不是HasOwnProperty操作
            4.deleteProperty(target, propKey)
                拦截delete proxy[propKey]的操作，返回一个布尔值。抛出错误或者返回false，当前属性就无法被delete命令删除
            5.ownKeys(target)
                拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。返回的数组成员，只能是字符串或 Symbol 值
                Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()、Object.keys()
                以下情况不触犯：目标对象上不存在的属性、属性名为 Symbol 值、不可遍历（enumerable）的属性
            6.getOwnPropertyDescriptor(target, propKey)
                拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。
            7.defineProperty(target, propKey, propDesc)
                拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。
            8.preventExtensions(target)
                拦截Object.preventExtensions(proxy)，返回一个布尔值。
            9.getPrototypeOf(target)
                拦截Object.getPrototypeOf(proxy)，返回一个对象。
                Object.prototype.__proto__、Object.prototype.isPrototypeOf()、Object.getPrototypeOf()、Reflect.getPrototypeOf()、instanceof
            10.isExtensible(target)
                拦截Object.isExtensible(proxy)，返回一个布尔值。
            11.setPrototypeOf(target, proto)
                拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
            12.apply(target, object, args)
                拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)、Reflect.apply(proxy,...)。
            13.construct(target, args)
                拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。返回的必须是一个对象
    如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错
    Proxy.revocable 返回一个可取消的 Proxy 实例
            {proxy, revoke} = Proxy.revocable(target, handler); revoke();
            标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问
    this 内部的this关键字会指向 Proxy 代理
            proxy = new Proxy(new Date(), {});proxy.getDate();//报错 由于this指向的变化
            proxy = new Proxy(new Date(), {get(target, prop) {
                if (prop === 'getDate') {return target.getDate.bind(target);}
                return Reflect.get(target, prop);
            }});
            proxy.getDate();
    可以做Web服务的客户端，实现数据库的 ORM 层

13、Reflect
    1.将Object对象的语言内部的方法（比如Object.defineProperty），放到Reflect对象上
    2.修改某些Object方法的返回结果，让其变得更合理。比如无法定义属性时不报错，而是返回false
    3.让Object的命令式操作都变成函数行为。比如name in obj->Reflect.has(obj, name)
    4.Reflect对象的方法与Proxy对象的方法一一对应
        Reflect.apply(target,thisArg,args)
            ==Function.prototype.apply.call(func, thisArg, args)
        Reflect.construct(target,args)
            == new target(...args)
        Reflect.get(target,name,receiver)  receiver绑定this
            Reflect.get({'foo':1}, 'foo')//1
            receiver={get name() {return 10;}
        Reflect.set(target,name,value,receiver)
            receiver={set name(value) {return this.foo = value;}
            会触发Proxy.defineProperty
        Reflect.defineProperty(target,name,desc)
            == Object.defineProperty
        Reflect.deleteProperty(target,name)
            == delete obj[name]
        Reflect.has(target,name)
            == name in obj
        Reflect.ownKeys(target)
            == Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和
        Reflect.isExtensible(target)
            == Object.isExtensible //当前对象是否可扩展
        Reflect.preventExtensions(target)
            == Object.preventExtensions //让一个对象变为不可扩展
        Reflect.getOwnPropertyDescriptor(target, name)
            == Object.getOwnPropertyDescriptor //得到指定属性的描述对象
        Reflect.getPrototypeOf(target)
            == Object.getPrototypeOf(obj) == __proto__
        Reflect.setPrototypeOf(target, prototype)
            ==Object.setPrototypeOf(obj, newProto) == __proto__=
    观察者模式
        queuedObservers = new Set();
        observe = fn => queuedObservers.add(fn);
        observable = obj => new Proxy(obj, {set});
        function set(target, key, value, receiver) {
            const result = Reflect.set(target, key, value, receiver);
            queuedObservers.forEach(observer => observer());
            return result;
        }
        function print() {console.log(`${person.name}, ${person.age}`)}
        observe(print);

14、Promise 对象
    简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果
        1.对象的状态不受外界影响  2.一旦状态改变，就不会再变，任何时候都可以得到这个结果
        Pending->Resolved和Pending->Rejected
        Stream 模式是比部署Promise更好
            var promise = new Promise(function(resolve, reject) {
                if (/* 异步操作成功 */){
                    resolve(value);
                } else {
                    reject(error);
                }
            });
            promise.then(function(value) {// success}, function(error) {// failure});
    一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。
    多个catch  .catch(function(error) {y + 2;}).catch(function(error) {console.log('carry on', error);});
        Promise.prototype.catch -> Promise.prototype.then(null, rejection)
        reject(new Error('test')); -> throw new Error('test');
    Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例
    Promise.race 方法同样是将多个Promise实例，包装成一个新的Promise实例。其中有一个实例率先改变状态，p的状态就跟着改变
    Promise.resolve 将现有对象转为Promise对象
        Promise.resolve('foo') 等价 new Promise(resolve => resolve('foo'))
        1.参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。
        2.参数是一个thenable对象(有then方法的对象)，会将这个对象转为Promise对象。
            Promise.resolve({then: function(resolve, reject) {resolve(42);}}).then(function(s) {console.log(s); });// 42
        3.参数不是具有then方法的对象，或根本就不是对象。返回一个新的Promise对象，状态为Resolved
            Promise.resolve('Hello').then(function(s) {console.log(s);});// 4Hello
        4.不带有任何参数
            setTimeout(function () {console.log('three');}, 0);
            Promise.resolve().then(function () {console.log('two');});
            console.log('one');
            Promise.resolve()在本轮“事件循环”结束时执行
    Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
    .done() 总是处于回调链的尾端，保证抛出任何可能出现的错误
    .finally() 它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行
    Promise.try 提案 不区分方法是同步还是异步
        1.(async () => f())().then(...).catch(...)
        2.(() => new Promise( resolve => resolve(f()) ))();

15、Iterator迭代器 和 for...of 循环
    遍历器对象本质上是一个指针对象,调用指针对象的next方法
    Iterator的作用
        1.是为各种数据结构，提供一个统一的、简便的访问接口；
        2.是使得数据结构的成员能够按某种次序排列；
        3.ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。
        arr = ['a', 'b', 'c'];iter = arr[Symbol.iterator]();iter.next()
        obj = {[Symbol.iterator] : function () {return {next: function () {return {value: 1,done: true};}};}};obj[Symbol.iterator]().next()
        iterable = {0: 'a',1: 'b',2: 'c',length: 3,[Symbol.iterator]: Array.prototype[Symbol.iterator]};
    调用场合
        1.解构赋值  对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。
        2.扩展运算符  扩展运算符（...）也会调用默认的iterator接口。
            arr = [...iterable]; 数据结构部署了Iterator接口，就可以使用扩展运算符转为数组。
        3.yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口
            generator = function* () {yield 1;yield* [2,3,4];yield 5;};
        4.其他
            for...of
            Array.from()
            Map(), Set(), WeakMap(), WeakSet()（比如new Map([['a',1],['b',2]])）
            Promise.all()
            Promise.race()
    Generator结合
        1.var myIterable = {};myIterable[Symbol.iterator] = function* () {yield 1;yield 2;yield 3;};[...myIterable] // [1, 2, 3]
        2.obj = {* [Symbol.iterator]() {yield 'hello';yield 'world';}};[...obj]//["hello", "world"]
    return()
        遍历提前返回时触发 break;
    throw()
        配合Generator函数使用
    for...of循环 作为遍历所有数据结构的统一的方法，只返回具有数字索引的属性
        范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。
        obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr); //arr的迭代方法复制给obj
        for...in循环(获得键名) + for...of循环(获得键值)= 数组实例的forEach方法
        对象
            for (let e in obj) { -> for (var key of Object.keys(obj)) {
            包装下 function* entries(obj) {for (let key of Object.keys(obj)) {yield [key, obj[key]];}}
    对比
        有着同for...in一样的简洁语法，但是没有for...in那些缺点。（遍历手动添加的其他键，以任意顺序遍历键名）
        不同于forEach方法，它可以与break、continue和return配合使用。
        提供了遍历所有数据结构的统一操作接口。

16、Generator 函数的语法
    异步编程解决方案，理解成是一个状态机，封装了多个内部状态。
    函数会返回一个遍历器对象,是 Generator 函数的实例
    调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象
    function* generator() {yield '1';yield '2';return '3';}
    hw = generator();hw.next();//{value: "1", done: false}
    [...{[Symbol.iterator]:generator}]//["1", "2"]
    g = generator();//g[Symbol.iterator]() === g;
    惰性求值
    通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值
        function* foo(x) {
            var y = 2 * (yield (x + 1));  //b.next() // { value:6, done:false }
            var z = yield (y / 3);  //b.next(12) // { value:8, done:false } 12*2/3
            return (x + y + z);  //b.next(13) // { value:42, done:true } 5+12*2+13
        }
    V8 引擎直接忽略第一次使用next方法时的参数
        function* dataConsumer() {
          console.log('Started');  //genObj.next();// Started
          console.log(`1. ${yield}`);//genObj.next('a');// 1. a
          return 'result';
        }
    for...of循环可以自动遍历 Generator 函数时生成的Iterator对象  return后面不返回
    通过 Generator 函数为对象加上遍历接口
        function* objectEntries(obj) {
            let propKeys = Reflect.ownKeys(obj);
            for (let propKey of propKeys) {
                yield [propKey, obj[propKey]];
            }
        }
        let jane = { first: 'Jane', last: 'Doe' };  -> jane[Symbol.iterator] = objectEntries;
        for (let [key, value] of objectEntries(jane)) { -> (let [key, value] of jane)
            console.log(`${key}: ${value}`);
        }
    throw 函数内部抛错
        throw方法被捕获以后，会附带执行下一条next表达式
    return 可以返回给定的值，并且终结遍历Generator函数。不传就是underfind
    yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数
        yield* generator; -> for (var value of generator) {yield value;}
        yield* ["a", "b", "c"];//有遍历方法就可以用
        内部的return会和外部下面的一个一起输出
            function *foo() {return "foo";}
            function *bar() {v = yield *foo();console.log( "v: " + v );yield 4;}
            bar().next();//v: foo  {value: 4, done: false}
        遍历嵌套数组、完全二叉树
    作为对象属性
        {* myGeneratorMethod() {}} -> {myGeneratorMethod: function* () {}}
    this
        function* F() {this.a = 1;yield this.b = 2;}
        obj = {};f = F.call(obj); ->  f = F.call(F.prototype); -> function F() {return F.call(F.prototype);};f = new F();
        obj.b //underfind 惰性
        f.next();obj.b // 2
    状态机
        var clock = function* () {while (true) {console.log('Tick!');yield;console.log('Tock!');yield;}};
    协程
        Generator 函数是 ES6 对协程的实现，但属于不完全实现。Generator 函数被称为“半协程”（semi-coroutine）
        只有 Generator 函数的调用者，才能将程序的执行权还给。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。
        只有 Generator 函数的调用者，才能将程序的执行权还给 Generator 函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行
        子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。
        最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。
    应用
        1.异步操作的同步化表达   Ajax 操作、逐行读取文本文件
        2.控制流管理
            for (var step of iterateJobs(jobs)) ->
            var res = it.next();
            while (!res.done){var result = res.value;res = it.next();}
        3.部署 Iterator 接口
            function* iterEntries(obj) {let keys = Object.keys(obj);for (let i=0; i < keys.length; i++) {let key = keys[i];yield [key, obj[key]];}}
            for (let [key, value] of iterEntries( { foo: 3, bar: 7 })) {console.log(key, value);}
        4.作为数据结构 类数组

17、Generator 函数的异步应用
    求值策略: 传值调用（先计算）,传名调用（先传表达式）  f(x+2)
    1.Generator 函数
        var g = gen(),var result = g.next();
        result.value.then(function(data){
            return data.json();
        }).then(function(data){
            g.next(data);
        });
    2.Thunk 函数: 编译器的“传名调用”实现
        Thunk = function(fn) {
            return function (...args) {
                return function (callback) {
                    return fn.call(this, ...args, callback);
                }
            };
        };
        使用：function f(a, cb) {cb(a);}ft = Thunk(f);ft(1)(console.log)
    Thunkify 模块 加了验证只调用一次回调
        function thunkify(fn) {
            return function() {
                var args = new Array(arguments.length);var ctx = this;
                for (var i = 0; i < args.length; ++i) {args[i] = arguments[i];}
                return function (done) {
                    var called;
                    args.push(function () {if (called) return;called = true;done.apply(null, arguments);});
                    try {fn.apply(ctx, args);} catch (err) {done(err);}
                }
            }
        };
        使用：var fs = require('fs'),thunkify = require('thunkify'),readFileThunk = thunkify(fs.readFile);
        var gen = function* (){
            var r1 = yield readFileThunk('/etc/fstab');console.log(r1.toString());
            var r2 = yield readFileThunk('/etc/shells');console.log(r2.toString());
        };
    co 模块  co = yield + Thunk & Promise
        var co = require('co');
        co(gen).then(function (){console.log('Generator 函数执行完成');});
        支持并发
            co(function* () {var res = yield [Promise.resolve(1),Promise.resolve(2)];}).catch(onerror)
            co(function* () {yield [n1, n2, n3].map(function* a(x) {});});

18、async 函数
    var asyncRead = async function () { -> async function asyncRead() {
        var f1 = await readFile('/etc/fstab');
        console.log(f1.toString());
    };
    async函数就是 Generator 函数的语法糖 星号（*）替换成async，将yield替换成await
        1.内置执行器,asyncRead()
        2.更好的语义,
        3.更广的适用性,await命令后面可以是Promise 对象和原始类型的值
        4.async函数的返回值是 Promise 对象
    async function asyncPrint(value, ms) {
        await new Promise((resolve) => {
            setTimeout(resolve, ms);
        });
        console.log(value);
    }
    //asyncPrint = async () => {};
    asyncPrint('hello world', 1000);
    reject不导致函数跳出
        try {await Promise.reject('出错了');} catch(e) { }
        await Promise.reject('出错了').catch(e => console.log(e));
    注：1、最好把await命令放在try...catch代码块中
        2、最好让异步同时触发 let [foo, bar] = await Promise.all([getFoo(), getBar()]);
        3、await命令只能用在async函数之中
    原理
        async function fn(args) {// ...} 等同 function fn(args) {return spawn(function* () {// ...});}
        function spawn(genF) {
          return new Promise(function(resolve, reject) {
            var gen = genF();
            function step(nextF) {
              try {
                var next = nextF();
              } catch(e) {
                return reject(e);
              }
              if(next.done) {
                return resolve(next.value);
              }
              Promise.resolve(next.value).then(function(v) {
                step(function() { return gen.next(v); });
              }, function(e) {
                step(function() { return gen.throw(e); });
              });
            }
            step(function() { return gen.next(undefined); });
          });
        }

19、Class
    类写法等价
        function Point(x, y) {this.x = x;this.y = y;}
        Point.prototype.toString = function () {return '(' + this.x + ', ' + this.y + ')';};
        ==
        class Point {
            constructor(x, y) {this.x = x;this.y = y;}
            toString() {return '(' + this.x + ', ' + this.y + ')';}
            ['a'](){}
        }
        var p = new Point(1, 2);
    类的实例上面调用方法，其实就是调用原型上的方法
        class B {}   b = new B();   b2 = new B();
        b.constructor === B.prototype.constructor === B
        b.__proto__ === b2.__proto__ === B.prototype //可改写原型，不推荐使用
    类的内部所有定义的方法，都是不可枚举  与 ES5 的行为不一致
        Object.keys(Point.prototype)  // []
        Object.getOwnPropertyNames(Point.prototype)  // ["constructor","toString"]
    举例
        class Point {
            constructor(x, y) {
                return Object.create(null); //修改 new Point()结果，不写就返回this
            }
            ['a'](){}//表达式命名
        }
        Point()//报错，一定要new
    定义在this对象上就是在实例上，未定义在this对象上的都是定义在原型上（即定义在class上）
        point.hasOwnProperty('toString') // false
        point.__proto__.hasOwnProperty('toString') // true
    表达式
        const MyClass = class Me {
          getClassName() {return Me.name;}
        };   new MyClass()
        person = new class {}();
    类不存在变量提升
    私有方法和私有属性  #
        const bar = Symbol('bar');
        const snaf = Symbol('snaf');
        export default class myClass{
          // 公有方法
          foo(baz) {
            this[bar](baz);
          }
          // 私有方法
          [bar](baz) {
            return this[snaf] = baz;
          }
        };
    this指向
        constructor() {this.printName = this.printName.bind(this);}
        constructor() {this.printName = () => {this.print(`Hello ${name}`);};}
        使用Proxy函数
    name属性 class关键字后面的类名
    get和set 对某个属性设置存值函数和取值函数
        class MyClass {
            get prop() {return 'getter';}//.prop
            set prop(value) {console.log('setter: '+value);}//.prop=1
        }
    类的静态方法  方法不会被实例继承，而是直接通过类来调用  可以被子类继承,可以从super对象上。
        class Foo {static classMethod() {return 'hello';}
        Foo.classMethod() // 'hello
        var foo = new Foo();foo.classMethod();//error
    类的静态属性 不继承，不推荐 Class 内部只有静态方法，没有静态属性
        Foo.prop = 1
    new.target
        不是通过new命令调用的会返回undefined，子类继承父类时，new.target会返回子类
        用于创建不能独立使用、必须继承后才能使用的类
        constructor() {if (new.target === Shape) {throw new Error('本类不能实例化');}}

20、Class 的继承
    继承constructor必须有super，写在最上面
        class ColorPoint extends Point {}
        ==
        class ColorPoint extends Point {
          constructor(...args) {
            super(...args);
          }
        }
    子类实例同时是子类和父类的实例 instanceof
    Object.getPrototypeOf(ColorPoint) === Point//从子类上获取父类
    super()相当于Point.prototype.constructor.call(this) super()内部的this指向的是ColorPoint
    super相当于Point.prototype  通过super调用父类的方法时，super会绑定子类的this
        constructor() {super();this.x = 2;super.x = 3;
            console.log(super.x); // undefinedconsole.log(this.x); // 3
        }
    super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象
        class Parent {
            static myMethod(msg) {console.log('static', msg);
            myMethod(msg) {console.log('instance', msg);}
        }

        class Child extends Parent {
          static myMethod(msg) {super.myMethod(msg);}
          myMethod(msg) {super.myMethod(msg);}
        }
        Child.myMethod(1); // static 1
        var child = new Child();child.myMethod(2); // instance 2
    由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。
        obj = {toString() {return "MyObject: " + super.toString();}};
        obj.toString(); // MyObject: [object Object]
    prototype和__proto__
        class A {}
        class B extends A {}
        B.__proto__ === A // true
        B.prototype.__proto__ === A.prototype
            继承原理
            class A {}  class B {}
            Object.setPrototypeOf(B.prototype, A.prototype);
            ==B.prototype.__proto__ = A.prototype; // B 的实例继承 A 的实例
            Object.setPrototypeOf(B, A);
            ==B.__proto__ = A; // B 的实例继承 A 的静态属性
    特殊继承
        1、class A extends Object {}
            A.__proto__ === Object // true
            A.prototype.__proto__ === Object.prototype // true
        2、class A {}
            A.__proto__ === Function.prototype // true
            A.prototype.__proto__ === Object.prototype // true
        3、class A extends null {}
            A.__proto__ === Function.prototype // true
            A.prototype.__proto__ === undefined // true
        4、Boolean、Number、String、Array、Date、Function、RegExp、Error、Object
            都可以继承
            ES6 改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6 规定Object构造函数会忽略参数  就是继承Object的super(...arguments)无效
    通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为
    Mixin 模式指的是，将多个类的接口“混入”（mix in）另一个类

21、Decorator
    修饰器（Decorator）是一个函数，用来修改类的行为 es2017
        @decorator  class A {} 等价 class A {} A = decorator(A) || A;
        function decorator(target) {target.isTestable = true;}
    支持多个参数
        @decorator1(true)
        function decorator1(isTestable) {return function(target) {target.isTestable = isTestable;}}
    添加实例对象 target.prototype.isTestable = true;
    React 与 Redux 库结合使用
        class MyReactComponent extends React.Component {}
        export default connect(mapStateToProps, mapDispatchToProps)(MyReactComponent);
        改为
        @connect(mapStateToProps, mapDispatchToProps)
        export default class MyReactComponent extends React.Component {}
    修饰类的属性
        class Person {
          @readonly
          name() { return `${this.first} ${this.last}` }
        }
        function readonly(target, name, descriptor){
          // descriptor对象原来的值如下
          // {
          //   value: specifiedFunction,
          //   enumerable: false,
          //   configurable: true,
          //   writable: true
          // };
          descriptor.writable = false;
          return descriptor;
        }
        readonly(Person.prototype, 'name', descriptor);
        // 类似于
        Object.defineProperty(Person.prototype, 'name', descriptor);
    如果同一个方法有多个修饰器，先从外到内进入，然后由内向外执行
        function dec(id){
            console.log('evaluated', id);
            return (target, property, descriptor) => console.log('executed', id);
        }
        class Example {
            @dec(1)
            @dec(2)
            method(){}
        }
        // evaluated 1
        // evaluated 2
        // executed 2
        // executed 1
    修饰器只能用于类和类的方法，因为函数提升不能用于函数,可以采用高阶函数的形式直接执行。
        function doSomething(name) {console.log('Hello, ' + name);}
        function loggingDecorator(wrapped) {
          return function() {
            console.log('Starting');
            const result = wrapped.apply(this, arguments);
            console.log('Finished');
            return result;
          }
        }
        const wrapped = loggingDecorator(doSomething);
    core-decorators.js是一个第三方模块
        1、@autobind修饰器使得方法中的this对象，绑定原始对象
        2、@readonly修饰器使得属性或方法不可写。
        3、@override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。
        4、@deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除
        5、@suppressWarnings修饰器抑制decorated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。
    将mixin写成一个修饰器。
        export function mixins(...list) {
          return function (target) {
            Object.assign(target.prototype, ...list);
          };
        }
        ==class MyClass extends MyBaseClass
    Trait也是一种修饰器，效果与Mixin类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等

22、Module 的语法
    import { stat, exists, readFile } from 'fs'; fs模块只加载3个方法。这种加载称为“编译时加载”或者静态加载
        1、不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。
        2、将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。
        3、不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。
    use strict 严格模式主要有以下限制。
        变量必须声明后再使用
        函数的参数不能有同名属性，否则报错
        不能使用with语句
        不能对只读属性赋值，否则报错
        不能使用前缀0表示八进制数，否则报错
        不能删除不可删除的属性，否则报错
        不能删除变量delete prop，会报错，只能删除属性delete global[prop]
        eval不会在它的外层作用域引入变量
        eval和arguments不能被重新赋值
        arguments不会自动反映函数参数的变化
        不能使用arguments.callee
        不能使用arguments.caller
        禁止this指向全局对象
        不能使用fn.caller和fn.arguments获取函数调用的堆栈
        增加了保留字（比如protected、static和interface）
    export
        export语句输出的接口，与其对应的值是动态绑定关系,与 CommonJS 规范完全不同
        如果处于块级作用域内，就会报错
        export var year = 1958;
        *export {year as Year,}; //脚本尾部
    import
        import { lastName as surname } from './profile';
        可以省略.js;不带有路径，要有配置文件
        import命令具有提升效果，会提升到整个模块的头部
        由于import是静态执行，所以不能使用表达式和变量
        import * as circle from 'lodash';//会执行所加载的模块
            import { foo } from 'my_module';
            import { bar } from 'my_module';
            // 等同于
            import { foo, bar } from 'my_module';
    export default
        export default function () {
          console.log('foo');//模块指定默认输出
        }
        -->import customName from './export-default'; customName();
        export {add as default}; 等同 export default add;
        import { default as xxx } from 'modules'; 等同于 import xxx from 'modules';
        import _, { each, each as forEach } from 'modules';
    import与export复合
        export { foo, bar } from 'my_module';
        // 等同于
        import { foo, bar } from 'my_module';
        export { foo, bar };
        1、export { foo as myFoo } from 'my_module';// 接口改名
        2、export * from 'my_module';// 整体输出
        3、export { default } from 'foo';//默认接口的写法
        4、export { es6 as default } from './someModule';//具名接口改为默认接口的写法
        5、export { default as es6 } from './someModule';//默认接口也可以改名为具名接口
            export const db = {}; // constants/db.js
            export const users = []; // constants/user.js
            export {db} from './db';
            export {users} from './users';// constants/index.js
            import {db, users} from './constants';// script.js
    import() 提议，用于动态加载模块
        import()返回一个 Promise 对象
        import()函数可以用在任何地方，运行时执行。
        import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。
        import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。
        1、按需加载  放在click事件的监听函数之中
        2、条件加载  放在if代码块
        3、动态的模块路径 函数返回

23、Module 的加载实现
    浏览器加载 ES6 模块 <script type="module" src="foo.js"></script>//自带defer
    对于外部的模块脚本（上例是foo.js），有几点需要注意。
        1、代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。
        2、模块脚本自动采用严格模式，不管有没有声明use strict。
        3、模块之中，可以使用import命令加载其他模块（.js不可省略，需要提供绝对 URL 或相对 URL），也可以使用export命令输出对外接口。
        4、模块之中，顶层的this关键字返回undefined，而不是指向window。也就是说，在模块顶层使用this关键字，是无意义的。
        5、同一个模块如果加载多次，将只执行一次。
    ES6 模块与 CommonJS 模块(module.exports)
        CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
        CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

25、ArrayBuffer
    ArrayBuffer对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图（TypedArray视图和DataView视图)来读写，视图的作用是以指定格式解读二进制数据。
        var buf = new ArrayBuffer(32);
        var dataView = new DataView(buf);
        dataView.getUint8(0) // 0






//尾递归优化
    function tco(f) {
        var value;
        var active = false;
        var accumulated = [];

        return function accumulator() {
            accumulated.push(arguments);
            if (!active) {
                active = true;
                while (accumulated.length) {
                    value = f.apply(this, accumulated.shift());
                }
                active = false;
                return value;
            }
        };
    }
    var sum = tco(function(x, y) {
        if (y > 0) {
            return sum(x + 1, y - 1)
        }else {
            return x
        }
    });

//jsx 源码
    define(function(require) {
        var React = require('react');

        var paramRegex  = /__(\d)+/;
        var parser      = new DOMParser();
        var errorDoc    = parser.parseFromString('INVALID', 'text/xml');
        var errorNs     = errorDoc.getElementsByTagName("parsererror")[0].namespaceURI;

        // turns the array of string parts into a DOM
        // throws if the result is an invalid XML document.
        function quasiToDom(parts) {

            // turn ["<div class='", "'>Hi</div>"]
            // into "<div class='__0'>Hi</div>"
            var xmlstr = parts.reduce((xmlstr, part, i) => {
                xmlstr += part;
                if (i != parts.length - 1) { // the last part has no ending param
                    xmlstr += `__${i}`;
                }

                return xmlstr;
            }, "");

           // parse into DOM, check for a parse error
           // browser's DOMParser is neat, but error handling is awful
           var doc      = parser.parseFromString(xmlstr, 'text/xml');
           var errors   = doc.getElementsByTagNameNS(errorNs, 'parsererror');
           var error    = '';
           if (errors.length > 0) {
               error = errors[0].textContent.split('\n')[0];
               throw `invalid jsx: ${error}\n${xmlstr}`;
           }

           return doc;
        }

        // turn a document into a tree of react components
        // replaces tags, attribute values and text nodes that look like the param
        // placeholder we add above, with the values from the parameters array.
        function domToReact(node, params) {
            var match;

            // text node, comment, etc
            if (node.nodeValue) {
                var value = node.nodeValue.trim();
                if (value.length === 0) {
                    return undefined;
                }

                match = value.match(paramRegex);
                return match ? params[parseInt(match[1])] : value;
            }

            // node to get react for
            // if the node name is a placeholder, assume the param is a component class
            var reactNode;
            match = node.localName.match(paramRegex)
            reactNode = match ? params[parseInt(match[1])] : React.DOM[node.localName];

            // if we don't have a component, give a better error message
            if (reactNode === undefined) {
                throw `Unknown React component: ${node.localName}, bailing.`;
            }

            // attributes of the node
            var reactAttrs = {};
            for (var i = node.attributes.length - 1; i >= 0; i--) {
                var attr = node.attributes[i];
                reactAttrs[attr.name] = attr.value;

                match = attr.value.match(paramRegex);
                if (match) {
                    reactAttrs[attr.name] = params[parseInt(match[1])];
                }
            }

            // recursively turn children into react components
            var reactChildren = [];
            for (var i = 0; i < node.childNodes.length; i++) {
                var child = node.childNodes[i];
                var reactChild = domToReact(child, params);
                if (reactChild) {
                    reactChildren.push(reactChild);
                }
            }

            return reactNode(reactAttrs, reactChildren);
        }

        return function jsx(parts, ...params) {
            var doc     = quasiToDom(parts);
            var react   = domToReact(doc.firstChild, params);
            return react;
        }
    });

//Mixin模式
    function mix(...mixins) {
      class Mix {}
      for (let mixin of mixins) {
        copyProperties(Mix, mixin);
        copyProperties(Mix.prototype, mixin.prototype);
      }
      return Mix;
    }
    function copyProperties(target, source) {
      for (let key of Reflect.ownKeys(source)) {
        if ( key !== "constructor"
          && key !== "prototype"
          && key !== "name"
        ) {
          let desc = Object.getOwnPropertyDescriptor(source, key);
          Object.defineProperty(target, key, desc);
        }
      }
    }
    //上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。

    class DistributedEdit extends mix(Loggable, Serializable) {
      // ...
    }

//V8引擎对map方法的实现如下。
    得到当前数组的this对象
    如果报错就返回
    求出当前数组的length属性
    如果报错就返回
    如果map方法的参数callbackfn不可执行，就报错
    如果map方法的参数之中，指定了this，就让T等于该参数，否则T为undefined
    生成一个新的数组A，跟当前数组的length属性保持一致
    如果报错就返回
    设定k等于0
    只要k小于当前数组的length属性，就重复下面步骤
    a. 设定Pk等于ToString(k)，即将K转为字符串
    b. 设定kPresent等于HasProperty(O, Pk)，即求当前数组有没有指定属性
    c. 如果报错就返回
    d. 如果kPresent等于true，则进行下面步骤
    d-1. 设定kValue等于Get(O, Pk)，取出当前数组的指定属性
    d-2. 如果报错就返回
    d-3. 设定mappedValue等于Call(callbackfn, T, «kValue, k, O»)，即执行回调函数
    d-4. 如果报错就返回
    d-5. 设定status等于CreateDataPropertyOrThrow (A, Pk, mappedValue)，即将回调函数的值放入A数组的指定位置
    d-6. 如果报错就返回
    e. k增加1
    返回A
    function ArrayMap(f, receiver) {
      CHECK_OBJECT_COERCIBLE(this, "Array.prototype.map");

      // Pull out the length so that modifications to the length in the
      // loop will not affect the looping and side effects are visible.
      var array = TO_OBJECT(this);
      var length = TO_LENGTH_OR_UINT32(array.length);
      return InnerArrayMap(f, receiver, array, length);
    }

    function InnerArrayMap(f, receiver, array, length) {
      if (!IS_CALLABLE(f)) throw MakeTypeError(kCalledNonCallable, f);

      var accumulator = new InternalArray(length);
      var is_array = IS_ARRAY(array);
      var stepping = DEBUG_IS_STEPPING(f);
      for (var i = 0; i < length; i++) {
        if (HAS_INDEX(array, i, is_array)) {
          var element = array[i];
          // Prepare break slots for debugger step in.
          if (stepping) %DebugPrepareStepInIfStepping(f);
          accumulator[i] = %_Call(f, receiver, element, i, array);
        }
      }
      var result = new GlobalArray();
      %MoveArrayContents(accumulator, result);
      return result;
    }
